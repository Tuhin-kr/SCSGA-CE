# If for each task , a certain maximum number of agents can work on it at a time , then 
import time
import random
import numpy as np

n_agents=100
n_tasks= 8

agent_utility=np.random.uniform(0 , 1, size=n_agents)  # Agent's percentage score
task_profit=np.random.uniform(100 , 500 , size=n_tasks)  # Task's profit value


#agent_utility = [0.78296773, 0.35004387, 0.59348329, 0.36707761, 0.94578829, 0.30936515,0.44295958, 0.03644696, 0.28111098, 0.18159622, 0.67836938, 0.56637095,0.0735777,  0.63205925, 0.98611006, 0.28418973, 0.98592218, 0.72778825,0.71989509, 0.20204182, 0.02948072, 0.89974783, 0.55280122, 0.08831614,0.77295974, 0.37022248, 0.40912216, 0.97313352, 0.11263762, 0.84357559,0.37345191, 0.21397098, 0.30768055, 0.49418087, 0.97894001, 0.24508085,0.18279225, 0.52183946, 0.68103007, 0.71678706, 0.00457074, 0.51340348,0.72831159, 0.87784553, 0.43874308, 0.24958418, 0.89213623, 0.11662852,0.41812319, 0.41018989, 0.68733731, 0.92877153, 0.34656931, 0.92072159,0.55414334, 0.666076,   0.99754724, 0.57445916, 0.09981361, 0.20032066,0.76679549, 0.26384783, 0.92561315, 0.19300924, 0.16637648, 0.16452942,0.24563572, 0.19474514, 0.285946,   0.41551576, 0.52838884, 0.14893214,0.39819589, 0.63407015, 0.55171422, 0.07595925, 0.03764509, 0.62124068,0.44614675, 0.54817525, 0.12336935, 0.58944205, 0.50259673, 0.50818646,0.82431842, 0.48483661, 0.61591464, 0.50914207, 0.22889506, 0.3063541,0.85202151, 0.34069623, 0.6766235,  0.59817866, 0.58252963, 0.91219806,0.18193449, 0.73133435, 0.9099739,  0.2648213]
#task_profit = [7, 2, 7, 8, 9, 3, 7, 1]
st = [ 10 , 11 , 16 , 10 , 13 , 10 , 18 , 12 ] # Maximum number of agents that can work on each task


print("Agent's utility: ", agent_utility)
print("Task's profit: ", task_profit)
print("Maximum number of agents that can work on each task: ", st)

agent_task_profit_matrix= np.zeros((n_agents, n_tasks)) # Each Agent-task profit calculation
for i in range(n_agents):
    for j in range(n_tasks):
       agent_task_profit_matrix[i][j]=(task_profit[j] * agent_utility[i])

# The element at the i-th row and j-th column represents the profit generated by the i-th agent when assigned to the j-th task.

def solution_value(final_assignment):  # Total solution value of a coalition structure

    """calculates the total profit of a given task assignment .
    
    Parameter:
        list[ list[int] ] : takes a list of lists as input , 
                            where each sublist represents a task and 
                            contains the indices of the agents assigned to that task

    Returns:
        int:    the sum of the profits of all tasks, which is the total profit of the given task assignment.
    """

    all_coalition_value=[]  # stores the total profit of each of the tasks
    for m in range (n_tasks):
        if len(final_assignment[m])==0: # If there are no agents assigned to the m-th task
            all_coalition_value.append(0)
        else:
            all_coalition_value.append(sum(agent_task_profit_matrix[final_assignment[m]][:,m])) # sum of the profits of the agents assigned to the m-th task
    return sum(all_coalition_value) # sum of the profits of all tasks


### Greedy Algorithm
greedy_start= time.time()

all_agents=[i for i in range(n_agents)]  # Taking all agent list
random_agent_permutation=random.sample(all_agents, n_agents) # Shuffle the agents in list

greedy_assignment=[[] for _ in range(n_tasks)]  # starting with blank assignment

for i in range(n_agents):
    temp_assign=[]
    
    for j in range(n_tasks):
        if(st[j] == 0): # If the j-th task has been already assigned its maximum number of agents
            temp_assign.append( -1 ) # Assigning -1 to the task to avoid assigning any more agents to it
            continue
        
        greedy_assignment[j].append(random_agent_permutation[i]) # inserting i-th agent into j-th task
        temp_assign.append( solution_value(greedy_assignment) )  # calculating solution value and storing those values in temp_assign
        greedy_assignment[j].remove(random_agent_permutation[i]) # remove that agent
    
    greedy_assignment[np.argmax(temp_assign)].append(random_agent_permutation[i]) # reinsert i-th agent into that task where max solution value achieved
    st[np.argmax(temp_assign)] -= 1 # Marking the task as assigned , and decrementing the count of agents that can be assigned to it

for i in range(n_tasks):
    print("Task ", i, " : ", greedy_assignment[i])

greedy_solution_value=solution_value(greedy_assignment)  # solution value of final assignment
print("Greedy solution value: ", greedy_solution_value)
greedy_end=time.time()

greedy_time= (greedy_end - greedy_start)
print("Time taken by greedy approach: {0:.18f} seconds ".format(greedy_time) )